{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Software engineer, trilingual speaker, open-source fan, love clouds and writing","text":"Quote.txt<pre><code>\"Let's write!\"\n</code></pre>"},{"location":"#hey-this-is-henry","title":"Hey, this is Henry!","text":"<p>Hey there, it's Henry! I'm a software engineer doing my thing in Taiwan. Take a peek at my blog \u2013 it's a mishmash of stuff like what I'm currently cooking up in my projects, some handy tutorials, and my quirky DIY hobbies. I also use it to note down things I might forget later. It's all pretty random, let's write! \u270d</p>"},{"location":"#some-random-facts-about-me","title":"Some random facts about me","text":"<ul> <li>Took a break from Facebook for years \u2013 just wasn't my scene.</li> <li>Started off training as an electronics engineer but ended up making a living as a software engineer.</li> <li>Spent a solid three years as a college teacher before diving into the world of development.</li> <li>Big fan of all kinds of birds, but parrots hold a special place in my heart.</li> <li>Strategy games are totally my thing, and right now, I'm deep into AOE4! \ud83c\udfae</li> </ul>"},{"location":"#connecting","title":"Connecting","text":"<p>Feel free to reach out to me athieubkhcm@gmail.com to say Hi! \u4f60\u597d! or Xin ch\u00e0o! I'm always happy to make new friends.</p>"},{"location":"#my-github","title":"My Github","text":""},{"location":"#my-linkedin","title":"My Linkedin","text":""},{"location":"IoTStack01_InstallationOnGCP/","title":"How to install IOTStack on Ubuntu and monitor all containers with Portainer.io","text":"<p>\"Hackers rarely have full knowledge of the technology stack of a target.\" - John McAfee</p> <p>Written by Henry Le on Oct 29, 2021</p> <p>As I recently start projects on the term and found that open-source community already built a very completed stack that can do almost everything one can imagine to do with IoT. So this article I would like to share how can IoTStack be installed on Ubuntu. I tested the process on both Google Cloud Platform and my local server, so I believe that this instruction works just fine with anyone else have interests in start to have fun with IOTStack.</p> <p>If you already have a RPI4 with you, the instruction of Andreas Spiess is a must-read.</p> <p>Firstly, making sure you already have everything packages updated and upgrades with:</p> <pre><code>sudo apt update\nsudo apt upgrade -y\n</code></pre> <p>And also curl if you are not sure that the package is already installed</p> <pre><code>sudo apt install curl\n</code></pre> <p>After having curl on your system, run the following command.</p> <pre><code>curl -fsSL https://raw.githubusercontent.com/SensorsIot/IOTstack/master/install.sh | bash\n</code></pre> <p>As default, a directory call /IOTStack will be created as your /home directory </p> <p>As you may see, there are two script file, install.sh and menu.sh, install.sh is indeed the script file we curl from the link above. By invokinng install.sh, another directory tree of IOTStack will then created and the content will be cloned just as the same as the parent folder we see here.</p> <p>Now, its time to see what we have in menu</p> <pre><code>cd ~\ncd /IOTStack\n./menu.sh\n</code></pre> <p></p> <p>Using your arrow keys to navigate around the menu, Build Stack is the first place we need to visit</p> <p>If you install IOTStack on a completely clean OS, without even docker installed, IOTStack will help you install the needed docker version.</p> <p></p> <p>If everything is running properly, a menu will be shown </p> <p>Navigating aroung by arrow keys and choosing the docker images by typing space bar. In my case, I choose grafana, influxdb, mosquitto, nodered, portainer-ce, portainer-agent, postgres, tasmoadmin and wireguard.</p> <p>At this point, you finished choosing your stack, assuming this is the first time you install IOTStack, there are no images or containers running in you system yet. The next step is making eveything up and running.</p> <p>Choosing the second option in the menu. </p> <p>There are several useful options in the Docker Commands menu, in this article I simply choosing Start Stack. The very first time building IOTStack might take a while because there are no existing images stored in your system yet. So for the first time, images of chosen option from the previous step will be automatically pulling to your system and then make it running.</p> <p>So far so good, the Stack after built up will look just as below, if there are any errors occur, error message will let you know while building up the stack.</p> <p></p> <p>To check whether the docker images was pulled to your system, enter the following command</p> <pre><code>docker images\n</code></pre> <p>To check the running containers</p> <pre><code>docker ps -a\n</code></pre>"},{"location":"IoTStack01_InstallationOnGCP/#monitoring-all-built-container-with-portainerio","title":"Monitoring all built container with portainer.io","text":"<p>If you try docker ps -a, by default you will see the container of portainer-ce is running with the IP exposed to outside. The port 9000 by default, is for administrators logging to the management webpage.  On your Web Browser (ie. Chrome, Firefox, etc). Enter localhost:9000/, this will open up the Web GUI of portainer-ce. </p> <p>You will need to secure your admin account's password the first time you logging to the Portainer. After logging in, the existing images and running containers are all shown up for your monitoring. Portainer provides various command buttons so that you can easily manipulate the Stack to certain levels. </p> <p>Basically, there are all the steps you need to operate when dealing with IOTStack for the first time, the result may different from time to time since the project IOTStack is actively updated by its contributors. By using the well prepared docker images of IOTStack, we save a lot of time from dealing with configuration. The heavy-lifting part is done for you so you can have more time spending on your business logic rather hours of configurating without knowing that they can work stably together.</p> <p>Thank you for reading my clumsy article, for more real life projects about IOTStack you can refer to this Link.</p>"},{"location":"about/","title":"Henry Le","text":""},{"location":"about/#software-engineer-trilingual-speaker-open-source-fan-love-clouds-and-writing","title":"Software engineer, trilingual speaker, open-source fan, love clouds and writing","text":"<p>Hey, I'm Henry! I'm a software engineer working in Taiwan. Welcome to my blog. Here, I write everything about what I like, projects currently working on, tutorials, DIY hobbies and anything else.</p> <p>Here is some random facts about me</p> <ul> <li>I start to write the blog since 2021</li> <li>I was trained to become an electronics engineer, but now doing software engineer for a living</li> <li>I worked as a teacher in college for 3 years before becoming a developer</li> <li>I love all kind of birds, especially parrots</li> <li>I love strategy games, especially StarCraft</li> </ul>"},{"location":"about/#connecting","title":"Connecting","text":"<p>You can contact me by hieubkhcm@gmail.com to drop any Hi! \u4f60\u597d! or Xin ch\u00e0o! I am very glad to make friends.</p>"},{"location":"about/#github","title":"Github","text":""},{"location":"about/#linkedin","title":"Linkedin","text":""},{"location":"cmake_01_hello_world/","title":"CMake - \"Hello world\"","text":""},{"location":"cmake_01_hello_world/#definition-from-wikipedia","title":"Definition from Wikipedia","text":"<p>In software development, CMake is cross-platform free and open-source software for build automation, testing, packaging and installation of software by using a compiler-independent method.</p> <p>So, clearly, CMake is not a build system but rather it generates another system's build files.</p>"},{"location":"cmake_01_hello_world/#source-code","title":"Source code","text":"<p>Lets have a simple mainapp.cpp that will flush to output the string \"Hello world!\"</p> mainapp.cpp<pre><code>#include&lt;stdio.h&gt;\u200b\n// ----------------------------------\u200b\n// Greeting message in English\u200b\n// ----------------------------------\u200b\nvoid  greeting_en()\u200b\n{\u200b\n    printf(\"Hello world!\\n\");\u200b\n}\u200b      \u200b\n// ----------------------------------\u200b\n// Main functions\u200b\n// ----------------------------------\u200b\nint  main(int  argc, char* argv[])\u200b\n{\u200b\n    greeting_en();\u200b\n    return 0;\u200b\n}\n</code></pre>"},{"location":"cmake_01_hello_world/#cmakelists","title":"CMakeLists","text":"<p>CMakeLists.txt that is put in the same level with mainapp.cpp with content:</p> CMakeLists.txt<pre><code># -------------------------------------------\u200b\n# The minimum version that required to be able to read this CMakeList.txt\u200b\n# -------------------------------------------\u200b\ncmake_minimum_required(VERSION 2.8.12)\u200b\n\u200b\n# -------------------------------------------\u200b\n# Project name often named as the binary (executable) file\u200b\n# -------------------------------------------\u200b\nproject(helloworld)\u200b\n\u200b\n# -------------------------------------------\u200b\n# Define the relationship between the the source code and the binary file\u200b\n# -------------------------------------------\u200b\nadd_executable(helloworld mainapp.cpp)\n</code></pre> <p>Putting the two files into the same directory, the hierarchy file can be seen by command tree as</p> <pre><code>root@ubuntu-22:/home/henry/HENRY_LAB/How_to_write_CMake/cmake_practice_01_single_source_code# tree\n.\n\u251c\u2500\u2500 CMakeLists.txt\n\u2514\u2500\u2500 mainapp.cpp\n</code></pre> <p>The file CMakeList.txt acts like a definition that CMake could understand, here we goes into the project before running the following command:</p> <pre><code>[root@base06 cmake_practice_01_single_source_code]# cmake .\u200b\n</code></pre> <p>Note: The dot \".\" is very important, it is the navigator to the path that store the file CMakeList.txt. In this case we can change it to $(PWD), the result should be the same.\u200b</p>"},{"location":"cmake_01_hello_world/#build-the-code","title":"Build the code","text":"<pre><code>root@ubuntu-22:/home/henry/HENRY_LAB/How_to_write_CMake/cmake_practice_01_single_source_code# cmake .\n-- The C compiler identification is GNU 11.2.0\n-- The CXX compiler identification is GNU 11.2.0\n-- Detecting C compiler ABI info\n-- Detecting C compiler ABI info - done\n-- Check for working C compiler: /usr/bin/cc - skipped\n-- Detecting C compile features\n-- Detecting C compile features - done\n-- Detecting CXX compiler ABI info\n-- Detecting CXX compiler ABI info - done\n-- Check for working CXX compiler: /usr/bin/c++ - skipped\n-- Detecting CXX compile features\n-- Detecting CXX compile features - done\n-- Configuring done\n-- Generating done\n-- Build files have been written to: /home/henry/HENRY_LAB/How_to_write_CMake/cmake_practice_01_single_source_code\n</code></pre> <p>As we can see, there are many files and folder created during the running of CMake. In this tutorial, we only focus on the Makefile  created</p> <p>Observe:\u200b</p> <ul> <li>CMake's duty is helping to generate Makefile, in other words, it is NOT helping us to build the project but to generate the Makefile  only and then . . . done!\u200b</li> <li>As Wikipedia defines, CMake is NOT a build system.</li> </ul> <p>So now, to build the project, we invoke Makefiles with command make\u200b\u200b</p> <pre><code>root@ubuntu-22:/home/henry/HENRY_LAB/How_to_write_CMake/cmake_practice_01_single_source_code# make\n[ 50%] Building CXX object CMakeFiles/helloworld.dir/mainapp.cpp.o\n[100%] Linking CXX executable helloworld\n[100%] Built target helloworld\n</code></pre> <p>The result will be an executable file named helloworld  as below\u200b</p> <pre><code>root@ubuntu-22:/home/henry/HENRY_LAB/How_to_write_CMake/cmake_practice_01_single_source_code# ls -la\ntotal 64\ndrwxrwxr-x  3 henry henry  4096  \u516b  31 21:56 .\ndrwxrwxr-x 10 henry henry  4096  \u516b  31 20:49 ..\n-rw-r--r--  1 root  root  14018  \u516b  31 21:50 CMakeCache.txt\ndrwxr-xr-x  5 root  root   4096  \u516b  31 21:56 CMakeFiles\n-rw-r--r--  1 root  root   1724  \u516b  31 21:50 cmake_install.cmake\n-rw-rw-r--  1 henry henry   583  \u516d   9 10:13 CMakeLists.txt\n-rwxr-xr-x  1 root  root  16000  \u516b  31 21:56 helloworld\n-rw-rw-r--  1 henry henry   351  \u516d   9 10:08 mainapp.cpp\n-rw-r--r--  1 root  root   5467  \u516b  31 21:50 Makefile\n</code></pre>"},{"location":"cmake_01_hello_world/#enjoy-the-result","title":"Enjoy the result","text":"<p>Execute the file, we see the expected result:\u200b</p> <pre><code>root@ubuntu-22:/home/henry/HENRY_LAB/How_to_write_CMake/cmake_practice_01_single_source_code# ./helloworld\nHello world!\n</code></pre> <p>Source code can be found here</p>"},{"location":"cmake_02_separated_build_folder/","title":"Separate build files and source code","text":""},{"location":"cmake_02_separated_build_folder/#scenario","title":"Scenario","text":"<p>After build the code, build files and its sub-files is in mixing. How to separate them to different directories?\u200b</p>"},{"location":"cmake_02_separated_build_folder/#result","title":"Result","text":"<p>Separated build files and source code</p>"},{"location":"cmake_02_separated_build_folder/#lets-firstly-look-at-the-source-code","title":"Lets firstly look at the source code","text":"<pre><code>$ tree\n.\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 build\n\u251c\u2500\u2500 include\n\u2502   \u251c\u2500\u2500 greetings_chinese.h\n\u2502   \u251c\u2500\u2500 greetings_english.h\n\u2502   \u2514\u2500\u2500 greetings_vietnamese.h\n\u2514\u2500\u2500 source\n    \u251c\u2500\u2500 greetings_chinese.cpp\n    \u251c\u2500\u2500 greetings_english.cpp\n    \u251c\u2500\u2500 greetings_vietnamese.cpp\n    \u2514\u2500\u2500 mainapp.cpp\n</code></pre> mainapp.cpp<pre><code>#include&lt;stdio.h&gt;\u200b\n#include&lt;greetings_english.h&gt;\u200b\n#include&lt;greetings_chinese.h&gt;\u200b\n#include&lt;greetings_vietnamese.h&gt;\u200b\n//\u200b\n// Main functions\u200b\n//\u200b\nint  main(int argc, char * argv[])\u200b\n{\u200b\n    greeting_en();\u200b\n    greeting_cn();\u200b\n    greeting_vi();\u200b\n    return 0;\u200b\n}\n</code></pre>"},{"location":"cmake_02_separated_build_folder/#header-files","title":"Header files","text":"greetings_english.h<pre><code>#include&lt;stdio.h&gt;\u200b\nvoid  greeting_en();\u200b\n</code></pre> greetings_chinese.h<pre><code>#include&lt;stdio.h&gt;\u200b\nvoid  greeting_cn();\u200b\n</code></pre> greetings_vietnamese.h<pre><code>#include&lt;stdio.h&gt;\u200b\nvoid  greeting_vi();\u200b\n</code></pre>"},{"location":"cmake_02_separated_build_folder/#source-files","title":"Source files","text":"greetings_english.cpp<pre><code>#include&lt;stdio.h&gt;\u200b\nvoid greeting_en()\u200b\n{\u200b\n    printf(\"Hello!\\n\");\u200b\n}\u200b\u200b\n</code></pre> greetings_chinese.cpp<pre><code>#include&lt;stdio.h&gt;\u200b\nvoid greeting_cn()\u200b\n{\u200b\n    printf(\"Nihao!\\n\");\u200b\n}\u200b\n</code></pre> greetings_vietnamese.cpp<pre><code>#include&lt;stdio.h&gt;\u200b\nvoid greeting_vi()\u200b\n{\u200b\n    printf(\"Xin chao!\\n\");\u200b\n}\u200b\n</code></pre>"},{"location":"cmake_02_separated_build_folder/#cmakeliststxt","title":"CMakeLists.txt","text":"<pre><code># ------------------------------------------- \u200b\n# The minimum version that required to be able to read this CMakeList.txt \u200b\n# ------------------------------------------- \u200b\n\ncmake_minimum_required(VERSION 2.8.12)\u200b\n# ------------------------------------------- \u200b\n# Project name often named as the binary (executable) file \u200b\n# ------------------------------------------- \u200b\nproject(helloworld)\u200b\n# ------------------------------------- \u200b\n# declare the directories that store project's file headers (.h) \u200b\n# ------------------------------------- \u200b\n\ninclude_directories(include)\u200b\n# -------------------------------------\u200b\n# adding source code file with command *set* \u200b\n# ------------------------------------- \u200b\n# set(SOURCES source/mainapp.cpp source/greetings_english.cpp source/greetings_chinese.cpp source/greetings_vietnamese.cpp)\u200b\n# ------------------------------------- \u200b\n# An alternative to set() is file(), this method is a good practice and \u200b\n# time-saving and also more common among developer community \u200b\n# And also, it support glob * \u200b\n# ------------------------------------- \u200b\nfile(GLOB SOURCES \"source/*.cpp\")\u200b\n# ------------------------------------------- \u200b\n# Define the relationship between the the source code and the binary file \u200b\n# ------------------------------------------- \u200b\nadd_executable(helloworld ${SOURCES}) \u200b\n</code></pre>"},{"location":"cmake_02_separated_build_folder/#build","title":"Build","text":"<p>\u200bWe change the directory to build folder and run the command cmake ..\u200b Double dot \"..\" means the upper layer that store the CMakeList.txt</p> <pre><code>[root@base06 build]# cmake ..\u200b\n-- The C compiler identification is GNU 4.8.5\u200b\n-- The CXX compiler identification is GNU 4.8.5\u200b\n- Check for working C compiler: /usr/bin/cc\u200b\n-- Check for working C compiler: /usr/bin/cc -- works\u200b\n-- Detecting C compiler ABI info\u200b\n-- Detecting C compiler ABI info - done\u200b\n-- Check for working CXX compiler: /usr/bin/c++\u200b\n-- Check for working CXX compiler: /usr/bin/c++ -- works\u200b\n-- Detecting CXX compiler ABI info\u200b\n-- Detecting CXX compiler ABI info - done\u200b\n-- Configuring done\u200b\n-- Generating done\u200b\n-- Build files have been written to: /home/henryle/CMake_Practice/cmake_practice_02_separated_build/build\u200b\n</code></pre> <p>Compiling procedure is quite like CMake \"Hello World\"</p> <p>Observe the file tree again</p> <pre><code>root@Henry-Legion5:/cmake_practice_02_separated_build# tree -L 2\n.\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 build\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 CMakeCache.txt\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 CMakeFiles\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 Makefile\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 cmake_install.cmake\n\u251c\u2500\u2500 include\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 greetings_chinese.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 greetings_english.h\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 greetings_vietnamese.h\n\u2514\u2500\u2500 source\n    \u251c\u2500\u2500 greetings_chinese.cpp\n    \u251c\u2500\u2500 greetings_english.cpp\n    \u251c\u2500\u2500 greetings_vietnamese.cpp\n    \u2514\u2500\u2500 mainapp.cpp\n</code></pre> <p>Run the Makefile in folder build\u200b</p> <pre><code>root@Henry-Legion5:/cmake_practice_02_separated_build/build# make\nScanning dependencies of target helloworld\n[ 20%] Building CXX object CMakeFiles/helloworld.dir/source/greetings_chinese.cpp.o\n[ 40%] Building CXX object CMakeFiles/helloworld.dir/source/greetings_english.cpp.o\n[ 60%] Building CXX object CMakeFiles/helloworld.dir/source/greetings_vietnamese.cpp.o\n[ 80%] Building CXX object CMakeFiles/helloworld.dir/source/mainapp.cpp.o\n[100%] Linking CXX executable helloworld\n[100%] Built target helloworld\n</code></pre> <p>Double check the file tree, we see the executable/binary file helloworld is generated in build folder\u200b</p> <pre><code>root@Henry-Legion5:/mnt/d/PROJECTS/How_to_write_CMake/cmake_practice_02_separated_build# tree -L 2\n.\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 build\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 CMakeCache.txt\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 CMakeFiles\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 Makefile\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 cmake_install.cmake\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 helloworld\n\u251c\u2500\u2500 include\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 greetings_chinese.h\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 greetings_english.h\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 greetings_vietnamese.h\n\u2514\u2500\u2500 source\n    \u251c\u2500\u2500 greetings_chinese.cpp\n    \u251c\u2500\u2500 greetings_english.cpp\n    \u251c\u2500\u2500 greetings_vietnamese.cpp\n    \u2514\u2500\u2500 mainapp.cpp\n</code></pre> <p>Execute the file helloworld, we see the expected result\u200b</p> <pre><code>root@Henry-Legion5:/cmake_practice_02_separated_build/build# ./helloworld\nHello!\nNihao!\nXin chao!\n</code></pre> <p>Source code can be found here</p>"},{"location":"cmake_03_build_a_shared_library_with_CMake/","title":"Export \"Hello World\" as a shared library (.so)","text":""},{"location":"cmake_03_build_a_shared_library_with_CMake/#scenario","title":"Scenario:\u200b","text":"<p>We want \"hello world\" is exported as a library to other project's usage\u200b</p>"},{"location":"cmake_03_build_a_shared_library_with_CMake/#result","title":"Result:\u200b","text":"<p>Using CMake to export the \"hello world\" project to 2 types of library, dynamic library and static lirary</p>"},{"location":"cmake_03_build_a_shared_library_with_CMake/#source-tree","title":"Source tree","text":"<p>Lets firstly have a look at what we have for the source tree. The files structure is similar to the previous post.</p> <pre><code>[root@base06 cmake_practice_03_project_to_lib_so]# tree\n.\n\u251c\u2500\u2500 build\u200b\n\u251c\u2500\u2500 CMakeLists.txt\u200b\n\u251c\u2500\u2500 include\u200b\n\u2502   \u251c\u2500\u2500 greetings_chinese.h\u200b\n\u2502   \u251c\u2500\u2500 greetings_english.h\u200b\n\u2502   \u2514\u2500\u2500 greetings_vietnamese.h\u200b\n\u2514\u2500\u2500 source\u200b\n    \u251c\u2500\u2500 greetings_chinese.cpp\u200b\n    \u251c\u2500\u2500 greetings_english.cpp\u200b\n    \u2514\u2500\u2500 greetings_vietnamese.cpp\n</code></pre> <p>Content of the each file is as follow</p>"},{"location":"cmake_03_build_a_shared_library_with_CMake/#header-files","title":"Header files","text":"<p>The same as previous post</p> greetings_english.h<pre><code>#include&lt;stdio.h&gt;\u200b\nvoid  greeting_en();\u200b\n</code></pre> greetings_chinese.h<pre><code>#include&lt;stdio.h&gt;\u200b\nvoid  greeting_cn();\u200b\n</code></pre> greetings_vietnamese.h<pre><code>#include&lt;stdio.h&gt;\u200b\nvoid  greeting_vi();\u200b\n</code></pre>"},{"location":"cmake_03_build_a_shared_library_with_CMake/#source-files","title":"Source files","text":"<p>The same as previous post</p> greetings_english.cpp<pre><code>#include&lt;stdio.h&gt;\u200b\nvoid greeting_en()\u200b\n{\u200b\n    printf(\"Hello!\\n\");\u200b\n}\n</code></pre> greetings_english.cpp<pre><code>#include&lt;stdio.h&gt;\u200b\nvoid greeting_cn()\u200b\n{\u200b\n    printf(\"Nihao!\\n\");\u200b\n}\n</code></pre> greetings_english.cpp<pre><code>#include&lt;stdio.h&gt;\u200b\nvoid greeting_vi()\u200b\n{\u200b\n    printf(\"Xin chao!\\n\");\u200b\n}\u200b\n</code></pre>"},{"location":"cmake_03_build_a_shared_library_with_CMake/#cmakeliststxt","title":"CMakeLists.txt","text":"<p>There is not much different from the post to the previous, but only we do not have main() function in any source files because we are building a library.</p>"},{"location":"cmake_03_build_a_shared_library_with_CMake/#cmakeliststxt_1","title":"CMakeLists.txt","text":"<p>CMakeLists.txt for generating .so library\u200b</p> <pre><code># -------------------------------------------\u200b\n# The minimum version that required to be able to read this CMakeList.txt\u200b\n# -------------------------------------------\u200b\ncmake_minimum_required(VERSION 2.8.12)\u200b\n# -------------------------------------------\u200b\n# Project name often named as the binary (executable) file\u200b\n# -------------------------------------------\u200b\nproject (multilang_greetings)\u200b\n# -------------------------------------\u200b\n# declare the directories that store project's file headers (.h)\u200b\n# -------------------------------------\u200b\ninclude_directories(include)\u200b\n# -------------------------------------\u200b\n# Adding the needed source files\u200b\n# -------------------------------------\u200b\nfile(GLOB SOURCES \"source/*.cpp\")\u200b\n# -------------------------------------------\u200b\n# Define which source files are include into the library\u200b\n# Type of the library is SHARED\u200b\n# name of the library can be differed from project name\u200b\n# -------------------------------------------\u200b\nadd_library(greetings_encnvi SHARED ${SOURCES})\n</code></pre> <p>Note:\u200b</p> <p>A dynamic library or a share object is shared between processes in system at runtime. CMake uses SHARED keyword in add_library() to indicate the type of library that will be generated.</p>"},{"location":"cmake_03_build_a_shared_library_with_CMake/#build","title":"Build","text":"<p>Run CMake and is as the same as previous post</p> <p>\u200bWe change the directory to build folder and run the command cmake ..\u200b \u200b After build the project, the .so library is the file that we expect as the result.\u200b</p> <pre><code>[root@ cmake_practice_03_project_to_lib_so]# tree -L 2\u200b\n.\u200b\n\u251c\u2500\u2500 build\u200b\n\u2502   \u251c\u2500\u2500 CMakeCache.txt\u200b\n\u2502   \u251c\u2500\u2500 CMakeFiles\u200b\n\u2502   \u251c\u2500\u2500 cmake_install.cmake\u200b\n\u2502   \u251c\u2500\u2500 libgreetings_encnvi.so\u200b\n\u2502   \u2514\u2500\u2500 Makefile\u200b\n\u251c\u2500\u2500 CMakeLists.txt\u200b\n\u251c\u2500\u2500 include\u200b\n\u2502   \u251c\u2500\u2500 greetings_chinese.h\u200b\n\u2502   \u251c\u2500\u2500 greetings_english.h\u200b\n\u2502   \u2514\u2500\u2500 greetings_vietnamese.h\u200b\n\u2514\u2500\u2500 source\u200b\n    \u251c\u2500\u2500 greetings_chinese.cpp\u200b\n    \u251c\u2500\u2500 greetings_english.cpp\u200b\n    \u2514\u2500\u2500 greetings_vietnamese.cpp\u200b\n</code></pre> <p>\u200bThe file libgreetings_encnvi.so\u200b is generated in build</p>"},{"location":"cmake_03_build_a_shared_library_with_CMake/#checking-the-library-with-ldd","title":"Checking the library with ldd","text":"<p>To double check the linking inside the library, we can run the command ldd as below</p> <pre><code>[root@base06 build]# ldd libgreetings_encnvi.so\u200b\n        linux-vdso.so.1 =&gt;  (0x00007ffc957c4000)\u200b\n        libstdc++.so.6 =&gt; /lib64/libstdc++.so.6 (0x00007f8f33d2f000)\u200b\n        libm.so.6 =&gt; /lib64/libm.so.6 (0x00007f8f33a2d000)\u200b\n        libc.so.6 =&gt; /lib64/libc.so.6 (0x00007f8f33449000)\u200b\n        /lib64/ld-linux-x86-64.so.2 (0x00007f8f34239000)\u200b\n</code></pre>"},{"location":"cmake_03_build_a_shared_library_with_CMake/#conlusion","title":"Conlusion","text":"<p>We have going through all the steps to have the library build project, as the result is the library that built with the linking is checked.</p> <p>Source code can be found HERE</p>"},{"location":"cmake_03_build_a_static_library_with_CMake/","title":"Export \"Hello World\" as a static library (.a)","text":"<p>The procedure to build static library is similar to build shared (dynamic) library as the previous post. But the only difference is CMakeLists.txt for generating .a library</p>"},{"location":"cmake_03_build_a_static_library_with_CMake/#cmakeliststxt","title":"CMakeLists.txt","text":"<pre><code># -------------------------------------------\u200b\n# The minimum version that required to be able to read this CMakeList.txt\u200b\n# -------------------------------------------\u200b\ncmake_minimum_required(VERSION 2.8.12)\u200b\n# -------------------------------------------\u200b\n# Project name often named as the binary (executable) file\u200b\n# -------------------------------------------\u200b\nproject (multilang_greetings)\u200b\n# -------------------------------------\u200b\n# declare the directories that store project's file headers (.h)\u200b\n# -------------------------------------\u200b\ninclude_directories(include)\u200b\n# -------------------------------------\u200b\n# Adding the needed source files\u200b\n# -------------------------------------\u200b\nfile(GLOB SOURCES \"source/*.cpp\")\u200b\n# -------------------------------------------\u200b\n# Define which source files are include into the library\u200b\n# Type of the library is STATIC\u200b\n# name of the library can be differed from project name\u200b\n# -------------------------------------------\u200b\nadd_library(greetings_encnvi STATIC ${SOURCES})\n</code></pre> <p>Note:\u200b</p> <p>Static library is defined in CMake by using STATIC keyword in add_library() to indicate the type of library that will be generated.</p> <p>Compare to generating .so library, generating .a file is not much different. The result is a .a library\u200b</p> <pre><code>[root@cmake_practice_03_project_to_lib_a]# tree -L 2\u200b\n.\u200b\n\u251c\u2500\u2500 build\u200b\n\u2502   \u251c\u2500\u2500 CMakeCache.txt\u200b\n\u2502   \u251c\u2500\u2500 CMakeFiles\u200b\n\u2502   \u251c\u2500\u2500 cmake_install.cmake\u200b\n\u2502   \u251c\u2500\u2500 libgreetings_encnvi.a\u200b\n\u2502   \u2514\u2500\u2500 Makefile\u200b\n\u251c\u2500\u2500 CMakeLists.txt\u200b\n\u251c\u2500\u2500 include\u200b\n\u2502   \u251c\u2500\u2500 greetings_chinese.h\u200b\n\u2502   \u251c\u2500\u2500 greetings_english.h\u200b\n\u2502   \u2514\u2500\u2500 greetings_vietnamese.h\u200b\n\u2514\u2500\u2500 source\u200b\n    \u251c\u2500\u2500 greetings_chinese.cpp\u200b\n    \u251c\u2500\u2500 greetings_english.cpp\u200b\n    \u2514\u2500\u2500 greetings_vietnamese.cpp\u200b\n</code></pre>"},{"location":"cmake_03_build_a_static_library_with_CMake/#checking-the-library-content","title":"Checking the library content","text":"<p>\u200b To double check the linking inside the library, we can run the command ar \u2013t as below\u200b</p> <pre><code>[root@build]# ar -t libgreetings_encnvi.a\u200b\ngreetings_vietnamese.cpp.o\u200b\ngreetings_english.cpp.o\u200b\ngreetings_chinese.cpp.o\n</code></pre> <p>Source code can be found HERE</p>"},{"location":"cmake_04_include_a_library_with_CMake/","title":"Include \"Hello World\" as library","text":""},{"location":"cmake_04_include_a_library_with_CMake/#scenario","title":"Scenario:\u200b","text":"<ul> <li> <p>At this point, we already has our own library, in both dynamic and static types.\u200b</p> </li> <li> <p>So, how to import the libs into our project using CMake\u200b \u200b</p> </li> </ul>"},{"location":"cmake_04_include_a_library_with_CMake/#result","title":"Result:\u200b","text":"<ul> <li>Using CMake to import the \"hello world\" project into our project and build an executable/binary file with the Makefile generated.</li> </ul>"},{"location":"cmake_04_include_a_library_with_CMake/#source-tree","title":"Source tree","text":"<p>Lets firstly have a look at what we have for the source tree.</p> <pre><code># tree\u200b\n.\u200b\n\u251c\u2500\u2500 build\u200b\n\u251c\u2500\u2500 CMakeLists.txt\u200b\n\u251c\u2500\u2500 include\u200b\n\u2502   \u251c\u2500\u2500 greetings_chinese.h\u200b\n\u2502   \u251c\u2500\u2500 greetings_english.h\u200b\n\u2502   \u251c\u2500\u2500 greetings_spanish.h\u200b\n\u2502   \u2514\u2500\u2500 greetings_vietnamese.h\u200b\n\u251c\u2500\u2500 lib\u200b\n\u2502   \u2514\u2500\u2500 libgreetings_encnvi.so\u200b\n\u2514\u2500\u2500 source\u200b\n    \u251c\u2500\u2500 greetings_spanish.cpp\u200b\n    \u2514\u2500\u2500 mainapp.cpp\n</code></pre>"},{"location":"cmake_04_include_a_library_with_CMake/#source-code","title":"Source code","text":"<p>Content of the each file is as follow</p> mainapp.cpp<pre><code>#include&lt;stdio.h&gt;\u200b\n#include&lt;greetings_english.h&gt;\u200b\n#include&lt;greetings_chinese.h&gt;\u200b\n#include&lt;greetings_vietnamese.h&gt;\u200b\n#include&lt;greetings_spanish.h&gt;\u200b\nint main(int argc, char * argv[])\u200b\n{\u200b\n    greeting_en();\u200b\n    greeting_cn();\u200b\n    greeting_vi();\u200b\n    greeting_es();\u200b\n    return 0;\u200b\n}\u200b\n</code></pre> greetings_english.h<pre><code>#include&lt;stdio.h&gt;\u200b\nvoid greeting_en();\u200b\n</code></pre> greetings_chinese.h<pre><code>#include&lt;stdio.h&gt;\u200b\nvoid greeting_cn();\u200b\n</code></pre> greetings_vietnamese.h<pre><code>#include&lt;stdio.h&gt;\u200b\nvoid greeting_vi();\u200b\n</code></pre> greetings_spanish.h<pre><code>#include&lt;stdio.h&gt;\u200b\nvoid greeting_es();\u200b\n</code></pre> greetings_spanish.h<pre><code>#include&lt;stdio.h&gt;\u200b\nvoid greeting_es()\u200b\n{\u200b\n    printf(\"Voila!\\n\");\u200b\n}\u200b\n</code></pre>"},{"location":"cmake_04_include_a_library_with_CMake/#cmakeliststxt-for-so-library","title":"CMakeLists.txt for .so library","text":"<p>CMakeLists.txt for generating Makefile with .so library\u200b</p> <pre><code># -------------------------------------------\u200b\n# The minimum version that required to be able to read this CMakeList.txt\u200b\n# -------------------------------------------\u200b\ncmake_minimum_required(VERSION 2.8.12)\u200b\n# -------------------------------------------\u200b\n# Project name often named as the binary (executable) file\u200b\n# -------------------------------------------\u200b\nproject (multilang_greetings)\u200b\n# -------------------------------------\u200b\n# declare the directories that store the library (.so)\u200b\n# -------------------------------------\u200b\nset (PROJECT_LINK_LIBS libgreetings_encnvi.so)\u200b\nlink_directories(lib)\u200b\n# -------------------------------------\u200b\n# declare the directories that store project's file headers (.h)\u200b\n# -------------------------------------\u200b\ninclude_directories(include)\u200b\n# -------------------------------------\u200b\n# Adding the needed source files\u200b\n# -------------------------------------\u200b\nfile(GLOB SOURCES \"source/*.cpp\")\u200b\n# -------------------------------------------\u200b\n# Define the relationship between the the source code and the binary file\u200b\n# -------------------------------------------\u200b\nadd_executable(helloworld_in_4lang ${SOURCES})\u200b\n# -------------------------------------------\u200b\n# Needed library is declared via PROJECT_LINK_LIBS\u200b\n# -------------------------------------------\u200b\ntarget_link_libraries(helloworld_in_4lang ${PROJECT_LINK_LIBS})\u200b\n</code></pre> <p>Note:\u200b</p> <ul> <li> <p>Compare to Know how 2, there is no library added to the project, in this case, we only need to declare in the CMakefile.txt the library that we use\u200b</p> </li> <li> <p>And the link between the build file and the library.</p> </li> </ul>"},{"location":"cmake_04_include_a_library_with_CMake/#build-project","title":"Build Project","text":"<p>We navigate to build folder, type cmake .. and make as usual:\u200b</p> <p>[root@base06 cmake_practice_04_include_so_lib_to_project]# cd build/\u200b</p> <pre><code>[root@base06 build]# cmake ..\u200b\n-- The C compiler identification is GNU 4.8.5\u200b\n-- The CXX compiler identification is GNU 4.8.5\u200b\n-- Check for working C compiler: /usr/bin/cc\u200b\n-- Check for working C compiler: /usr/bin/cc -- works\u200b\n-- Detecting C compiler ABI info\u200b\n-- Detecting C compiler ABI info - done\u200b\n-- Check for working CXX compiler: /usr/bin/c++\u200b\n-- Check for working CXX compiler: /usr/bin/c++ -- works\u200b\n-- Detecting CXX compiler ABI info\u200b\n-- Detecting CXX compiler ABI info - done\u200b\n-- Configuring done\u200b\n-- Generating done\u200b\n-- Build files have been written to: /home/henryle/CMake_Practice/cmake_practice_04_include_so_lib_to_project/build\u200b\n</code></pre> <pre><code>[root@base06 build]# make\u200b\nScanning dependencies of target helloworld_in_4lang\u200b\n[ 50%] Building CXX object CMakeFiles/helloworld_in_4lang.dir/source/greetings_spanish.cpp.o\u200b\n[100%] Building CXX object CMakeFiles/helloworld_in_4lang.dir/source/mainapp.cpp.o\u200b\nLinking CXX executable helloworld_in_4lang\u200b\n[100%] Built target helloworld_in_4lang\u200b\n</code></pre>"},{"location":"cmake_04_include_a_library_with_CMake/#execute","title":"Execute","text":"<p>Execute the binary file, and checking the result\u200b</p> <pre><code>[root@base06 build]# ./helloworld_in_4lang\u200b\nHello!\u200b\nNihao!\u200b\nXin chao!\u200b\nVoila!\u200b\n</code></pre>"},{"location":"cmake_04_include_a_library_with_CMake/#static-a-to-project","title":"Static .a to project","text":"<p>Note:\u200b</p> <p>There is not much different when include a .so and but replacing the .a library to the project.\u200b</p> <pre><code>[root@base06 cmake_practice_04_include_a_lib_to_project]# tree\u200b\n.\u200b\n\u251c\u2500\u2500 build\u200b\n\u251c\u2500\u2500 CMakeLists.txt\u200b\n\u251c\u2500\u2500 include\u200b\n\u2502   \u251c\u2500\u2500 greetings_chinese.h\u200b\n\u2502   \u251c\u2500\u2500 greetings_english.h\u200b\n\u2502   \u251c\u2500\u2500 greetings_spanish.h\u200b\n\u2502   \u2514\u2500\u2500 greetings_vietnamese.h\u200b\n\u251c\u2500\u2500 lib\u200b\n\u2502   \u2514\u2500\u2500 libgreetings_encnvi.a\u200b\n\u2514\u2500\u2500 source\u200b\n    \u251c\u2500\u2500 greetings_spanish.cpp\u200b\n    \u2514\u2500\u2500 mainapp.cpp\u200b\n</code></pre>"},{"location":"cmake_04_include_a_library_with_CMake/#cmakeliststxt-for-a-library","title":"CMakeLists.txt for .a library","text":"<p>CMakeLists.txt for generating Makefile with .a library\u200b</p> CMakeLists.txt<pre><code># -------------------------------------------\u200b\n# The minimum version that required to be able to read this CMakeList.txt\u200b\n# -------------------------------------------\u200b\ncmake_minimum_required(VERSION 2.8.12)\u200b\n# -------------------------------------------\u200b\n# Project name often named as the binary (executable) file\u200b\n# -------------------------------------------\u200b\nproject (multilang_greetings)\u200b\n# -------------------------------------\u200b\n# declare the directories that store the library (.so)\u200b\n# -------------------------------------\u200b\nset (PROJECT_LINK_LIBS libgreetings_encnvi.a)\u200b\nlink_directories(lib)\u200b\n# -------------------------------------\u200b\n# declare the directories that store project's file headers (.h)\u200b\n# -------------------------------------\u200b\ninclude_directories(include)\u200b\n# -------------------------------------\u200b\n# Adding the needed source files\u200b\n# -------------------------------------\u200b\nfile(GLOB SOURCES \"source/*.cpp\")\u200b\n# -------------------------------------------\u200b\n# Define the relationship between the the source code and the binary file\u200b\n# -------------------------------------------\u200b\nadd_executable(helloworld_in_4lang ${SOURCES})\u200b\n# -------------------------------------------\u200b\n# Needed library is declared via PROJECT_LINK_LIBS\u200b\n# -------------------------------------------\u200b\ntarget_link_libraries(helloworld_in_4lang ${PROJECT_LINK_LIBS})\u200b\n</code></pre> <p>Note:\u200b</p> <ul> <li> <p>In this case, we only need to declare in the CMakefile.txt the library that we use\u200b</p> </li> <li> <p>And the link between the build file and the library.\u200b</p> </li> <li> <p>To build binary file, the operation is absolute just like including with .so lib\u200b</p> </li> </ul> <p>Source code can be found HERE</p>"},{"location":"cmake_extra01_functions_explanation/","title":"CMake functions: some explanation","text":"<pre><code>make_minimum_required(VERSION 3.10)\n</code></pre> <p>cmake_minimum_required() : the minimum version that CMake needs to be so that the CMakeLists.txt can be read. Check version of CMake in the system by cmake --version</p> <pre><code>project(Tutorial VERSION 1.0)\n</code></pre> <p>project() : giving the name to the project, version of a project can be modified here</p> <pre><code>set(CMAKE_CXX_STANDARD 11) set(CMAKE_CXX_STANDARD_REQUIRED True)\n</code></pre> <p>set(): some kind of configuration or setting a variable, with CMake</p> <pre><code>option(USE_MYMATH \"use tutorial provided math implementataion\" ON)\n</code></pre> <p>option(): declare options for Dev/User to be able to change build options quickly, for example, different os or use different APIs depending on the environment</p> <pre><code>configure_file([TutorialConfig.h.in](http://tutorialconfig.h.in/) TutorialConfig.h)\n</code></pre> <p>configure_file() : pass environment variables from outside the code into the code, for example, VERSION 1.0 from project(), passed as @Tutorial_VERSION_MAJOR@ \u2192 via macro and header pass the value to Tutorial_VERSION_MAJOR inside the code, after build and run, you will see the Version magically appear</p> <p>add_subdirectory() : this command to add a folder during the build process to find a library</p> <p>list(APPEND a_variable): append a variable to a list, useful when adding a bundle of sourcecode to build a targer</p> <pre><code>add_executable(Tutorial tutorial.cxx)\n</code></pre> <p>add_executable() : Simply understand it as a way to declare the relationship between the binary named Tutorial and the related source files</p> <pre><code>target_link_libraries(Tutorial PUBLIC ${EXTRA_LIBS})\n</code></pre> <p>target_link_libraries(): declare the target that is called this Tutorial that needs the libs in list of libs in EXTRA_LIBS.</p> <pre><code>target_include_directories(Tutorial PUBLIC \"${PROJECT_BINARY_DIR}\" ${EXTRA_INCLUDES} )\n</code></pre> <p>target_include_directories() : Similar to the above, this command to declare which directories are relevant (containing some libs).</p>"},{"location":"leveldb_01_hello_world/","title":"An example of using levelDB","text":""},{"location":"leveldb_01_hello_world/#target","title":"Target:\u200b","text":"<ul> <li>In this post, I will explain how to write a simple program that can utilize the API that provide by levelDB</li> </ul>"},{"location":"leveldb_01_hello_world/#some-facts","title":"Some facts:","text":"<ul> <li>LevelDB is a database that embedded into the process rathen running independently just as Postgresql or MongoDB.</li> <li>The data that is stored in levelDB is straightforward, that simply pairs of KV, Key and Value.</li> <li>LeveDB support a set of API so users can call, and there not too many of commands that we can call here.</li> </ul>"},{"location":"leveldb_01_hello_world/#lets-see-with-source-tree","title":"Lets see with source tree:","text":"<p>Here we have a single source code that include the header leveldb/db.h</p> <pre><code>root@Henry-WIN:leveldb_practice# tree\n.\n\u2514\u2500\u2500 leveldb_example.cpp\n</code></pre>"},{"location":"leveldb_01_hello_world/#source-code","title":"Source code","text":"<p>Content of the file is as follow</p> <p>leveldb_example.cpp<pre><code>#include &lt;iostream&gt;\n#include &lt;string&gt;\n#include &lt;assert.h&gt;\n#include &lt;unistd.h&gt;\n#include \"leveldb/db.h\"\n\nusing namespace std;\n\n// build the code with $ g++ -o leveldb_example leveldb_example.cpp -lleveldb\nint main (void)\n{\n    leveldb::DB *db;\n    leveldb::Options options;\n\n    options.create_if_missing = true;\n    //open\n    leveldb::Status status = leveldb::DB::Open(options, \"/tmp/testdb\", &amp;db);\n    assert(status.ok());\n\n    string key = \"name\";\n    string value = \"HenryLe\";\n\n    // write - PUT\n    status = db-&gt;Put(leveldb::WriteOptions(), key, value);\n    assert(status.ok());\n    cout &lt;&lt; \"=== Write K:[\" &lt;&lt; key &lt;&lt; \"] V:[\" &lt;&lt; value &lt;&lt; \"] to DB\"  &lt;&lt; endl;\n\n    // read - GET\n    status = db-&gt;Get(leveldb::ReadOptions(), key, &amp;value);\n    assert(status.ok());\n    cout &lt;&lt; \"=== Read K:[\"  &lt;&lt; key &lt;&lt; \"] V:[\" &lt;&lt; value &lt;&lt; \"] from DB\" &lt;&lt; endl;\n\n    // delete - DELETE\n    status = db-&gt;Delete(leveldb::WriteOptions(), key);\n    assert(status.ok());\n\n    status = db-&gt;Get(leveldb::ReadOptions(), key, &amp;value);\n    if (!status.ok())\n    {\n        cerr &lt;&lt; \"=== Failed to read kv after deletion: [\" &lt;&lt; key &lt;&lt; \"] Status: \" &lt;&lt; status.ToString()  &lt;&lt; endl;\n    }\n    else\n    {\n        cout &lt;&lt; key &lt;&lt; \"===\" &lt;&lt; value &lt;&lt; endl;\n    }\n    // usleep(20000000);\n\n    // close\n    delete db;\n\n    return 0;\n}\n</code></pre> The flow of the code is as follow:</p> <ul> <li>We open the database with leveldb::DB::Open()</li> <li>We write/put data to the database, in this case a pair of Key|Value -- name|Henry</li> <li>We read/get the data from the database to see if the data is written to database properly</li> <li>We delete the data</li> <li>And finally, we read the data again and see the confirmation that the data is deleted</li> </ul>"},{"location":"leveldb_01_hello_world/#build-the-program","title":"Build the program","text":"<p>To build the program, we type the command below</p> <pre><code>$ g++ -o leveldb_example leveldb_example.cpp -lleveldb\u200b\n</code></pre> <p>Note:\u200b</p> <ul> <li> <p>To successfully build the program, the system need to installed leveldb. Otherwise, the compiling will fail due to lack of library that need for the build.</p> </li> <li> <p>To install levelDB, refer to Google/leveldb</p> </li> </ul>"},{"location":"leveldb_01_hello_world/#execute","title":"Execute","text":"<p>After compile the program, in your source will have the compiled/binary file as beloy:</p> <pre><code>root@Henry-WIN:leveldb_practice# tree\n.\n\u251c\u2500\u2500 leveldb_example\n\u2514\u2500\u2500 leveldb_example.cpp\n</code></pre> <p>Now, lets run the program to see the result:</p> <pre><code>root@Henry-WIN:leveldb_practice# ./leveldb_example\n=== Write K:[name] V:[HenryLe] to DB\n=== Read K:[name] V:[HenryLe] from DB\n=== Failed to read kv after deletion: [name] Status: NotFound:\n</code></pre> <p>The data the content Key|Value name|Henry is written to database. Then read from database, then deleted, and after deleted, we read the data and receive warning that the data is not found in the database. All work as expected.</p> <p>This short tutorial is a note so that I can refer later to when I need it.</p> <p>Source code can be found HERE</p>"}]}